<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QuickChart</title>

  <!-- Bootstrap 5 (CDN) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <!-- SortableJS (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <!-- Fuse.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>

  <style>
    body {
      padding: 1rem;
    }

    .dchart-section {
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
      position: relative;
    }

    .section-header {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    .section-title {
      margin: 0;
    }

    .sentence-list {
      list-style: none;
      padding-left: 0;
      margin-bottom: 0;
      min-height: 2rem; /* space to drop even if empty */
    }

    .sentence-list li {
      background: #ffffff;
      padding: 0.5rem 2rem 0.5rem 2rem;
      margin-bottom: 0.5rem;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      position: relative;
    }

    /* Drag handle on the left side */
    .drag-handle {
      position: absolute;
      left: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      cursor: move;
      font-size: 1.2rem;
      user-select: none;
    }

    /* The red X button to remove a sentence */
    .remove-sentence-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      color: red;
      font-size: 1.2rem;
      font-weight: bold;
      background: transparent;
      border: none;
      cursor: pointer;
      outline: none;
    }
    .remove-sentence-btn:hover {
      color: darkred;
    }

    .add-item-form {
      display: inline-block;
      width: 100%;
      position: relative;
    }
    .add-item-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      align-items: center;
      width: 100%;
    }
    .add-item-form input[type="text"] {
      flex: 1;
    }
    /* Suggestions container for the "Add new sentence" field */
    .suggestions-box {
      position: absolute;
      left: 0;
      right: 0;
      top: 42px; /* just below the input */
      z-index: 999;
      background: white;
      border: 1px solid #ced4da;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
    .suggestions-box ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .suggestions-box li {
      padding: 6px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    .suggestions-box li:hover {
      background-color: #f2f2f2;
    }

    /* Inline placeholders smaller & dotted underline */
    .inline-field {
      display: inline-block;
      width: auto;
      min-width: 50px;
      margin: 0 3px;
      vertical-align: baseline;
      font-size: 1em;
      border: none;
      border-bottom: 1px dotted #777;
      background-color: transparent;
      padding: 0 2px;
      outline: none;
      text-align: left;
    }
    .inline-field::placeholder {
      text-align: center;
    }
    .inline-field:focus {
      border-bottom-color: #000;
    }

    /* Custom dropdown for placeholders (like [customDropdown:IV Size]) */
    .custom-dropdown {
      display: inline-block;
      position: relative;
    }
    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 999;
      display: none;
      margin-top: 4px;
      width: 200px;
      max-height: 200px;
      overflow-y: auto;
      background-color: #fff;
      border: 1px solid #ced4da;
      border-radius: 4px;
      padding: 0;
      list-style: none;
    }
    .suggestions li {
      padding: 0.5rem;
      cursor: pointer;
    }
    .suggestions li:hover,
    .suggestions li.highlight {
      background-color: #e9ecef;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="d-flex align-items-center justify-content-between mb-4">
    <h1 class="m-0">QuickChart</h1>
    <div class="form-check form-switch">
      <input class="form-check-input" type="checkbox" id="toggleSectionTitles" checked />
      <label class="form-check-label" for="toggleSectionTitles">
        Include Section Titles in Final Output
      </label>
    </div>
  </div>

  <!-- Container for parts (D, C, H, A, R, T, M, Sign Off) -->
  <div id="sectionContainer"></div>

  <!-- Generate final text button -->
  <button id="generateBtn" class="btn btn-primary mb-3">Generate Final Text</button>

  <!-- Final text preview / copy area -->
  <div class="mb-3">
    <label class="form-label fw-bold">Final Narrative</label>
    <textarea class="form-control" id="finalText" rows="4"></textarea>
  </div>

  <!-- Copy button -->
  <button id="copyBtn" class="btn btn-success mb-5">Copy to Clipboard</button>

  <!-- Disclaimer -->
  <div class="alert alert-secondary py-1 text-center" role="alert">
    <strong>Disclaimer:</strong> No information is stored or sent to a server. 
    All data is stored in your browser's memory.
  </div>
</div>

<!-- Bootstrap 5 JS -->
<script
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
></script>

<script>
/* 
  We'll store each "common" sentence with three forms:
  1) original   - the exact text with placeholders
  2) display    - a shortened version for suggestions (like [IV Size])
  3) searchable - an expanded placeholder version so searching "14G" or "IV" can match
*/

// Regex for placeholders
const placeholderRegex = /\[(text|number|dropdown|customDropdown):([^:\]]+)(?::([^:\]]+))?\]/g;

// Our raw "common sentences"
const rawCommonSentences = [
  "The patient had [customDropdown:IV Size:14G,16G,18G,20G,22G,24G] IV placed in the [customDropdown:IV Location:left arm,right arm,left hand,right hand] ",
  "The patient was on a ventilator [customDropdown:Ventilator Mode:AC,PC,PSV,CPAP] with the following settings: pressure control [number:Pressure], rate [number:Rate], FiO2 [number:FiO2], PEEP [number:PEEP], and tidal volume [number:Tidal Volume].",
  "The patient was [number:Rate]lmp O2 via [customDropdown:O2 Delivery Device:Nasal Cannula,High Flow Nasal Cannula,Simple Mask,Non-Rebreather Mask,CPAP,Venturi Mask]",
  "The patient's GCS was assessed as [number:GCS] ([number:GCS Eye],[number:GCS Verbal],[number:GCS Motor])"
];

/* 
  Build array of objects:
*/
const commonSentences = rawCommonSentences.map(s => ({
  original: s,
  display: shortPlaceholderString(s),
  searchable: expandedPlaceholderString(s)
}));

/* 
  Fuse config: 
  - We'll search across both "display" and "searchable"
  - minMatchCharLength = 2, threshold = 0.01 => quite strict 
  - ignoreLocation = true => doesn't matter where in the string it is 
*/
const fuseOptions = {
  keys: ["display", "searchable"],
  includeMatches: true,
  threshold: 0.01,
  minMatchCharLength: 2,
  ignoreLocation: true
};
const fuse = new Fuse(commonSentences, fuseOptions);

/* 
  Global custom dropdown options for placeholders like [customDropdown:IV Size].
  If inline options exist, they override these. 
*/
const globalDropdownOptions = {
  "Unit #": ["Medic 5", "Medic 6"],
  "Gender": ["Male", "Female"],
  "Response Type": ["emergent", "non-emergent"],
  "Hospitalized / Evaluated": ["hospitalized", "evaluated"],
  "Mental Status": ["alert and oriented", "confused"],
  "Method": ["sheet draw", "stand and pivot"],
  "Assist Count": ["x1", "x2"],
  "Straps Count": ["x5"],
  "Patient Condition": ["improved", "did not change", "worsened"],
  "Transfer of Location": ["hospital bed"],
  "Sending Facility": ["Baptist Floyd", "Baptist Freestanding ER in Jeffersonville"],
  "Reason": ["higher level of care", "long term care"],
  "Medical Necessity": [
    "1: Patient was bed confined before and after transport",
    "2: Patient required Cardiac / Hemodynamic monitoring during transport",
    "3: Patient is confused, combatative, lethargic, or comatose",
    "4: Patient has contractures",
    "5: Patient is a danger to self or others - requires monitoring",
    "6: Patient has DVT required elevation of lower extremity",
    "7: Patient requires IV Medications / Fluids during transport",
    "8: Patient has moderate to severe pain upon movement",
    "9: Patient is morbidly obese and requires additional personnel / equipment",
    "10: Patient has non healing fractures",
    "11: Patient requires orthopedic device requiring special handling in transit",
    "12: Patient requires or medical provider anticapates restraints (Physical or Chemical)",
    "13: Patient has a risk of falling off wheelchair or stretcher while in motion",
    "14: Patient has severe muscular weakness",
    "15: Patient requires special handling en route - Isolation",
    "16: Patient requires assistance for administration / regulation of oxygen",
    "17: Patient is unable to maintain seated position for time needed to transport",
    "18: Patient is unable to sit in chair or wheelchair due to decubitus ulcer",
    "19: Patient requires transfer for higher level of care; First hospital lacks equipment / sercives"
  ],
};

/* 
  Our main data structure with sections "D", "C", "H", "A", "R", "T", "M", "Sign Off".
  Each has a boolean to control if the title is included, 
  and an array of sentences with placeholders. 
*/
let dchartSections = [
  {
    part: "D",
    includeTitle: true,
    sentences: [
      {
        text: "[customDropdown:Unit #] was dispatched to [customDropdown:Sending Facility] for [number:Age]yo [customDropdown:Gender]."
      },
      {
        text: "The response was [customDropdown:Response Type]."
      },
      {
        text: "Upon arrival, the patientâ€™s condition was [text:Initial Condition]."
      },
      {
        text: "No immediate intervention or additional resources were required."
      }
    ]
  },
  {
    part: "C",
    includeTitle: true,
    sentences: [
      {
        text: "The patientâ€™s chief complaint is [text:Chief Complaint], which has been ongoing for [number:Duration] [customDropdown:Duration Units:Minutes, Hours, Days, Weeks, Years]."
      }
    ]
  },
  {
    part: "H",
    includeTitle: true,
    sentences: [
      {
        text: "The patient was recently [customDropdown:Hospitalized / Evaluated] for [text:Reason]."
      },
      {
        text: "The patientâ€™s medical history, medications, and allergies are detailed in the HPI. The OPQRST assessment, along with the SAMPLE history, is documented above."
      },
      {
        text: "Including [text:Pertinent Positive Findings]."
      }
    ]
  },
  {
    part: "A",
    includeTitle: true,
    sentences: [
      {
        text: "The patientâ€™s mental status was assessed as [customDropdown:Mental Status], with ABCs evaluated as [text:ABCs]."
      },
      {
        text: "Primary assessment findings, documented in the treatment tab, revealed [text:Assessment Status]."
      },
      {
        text: "Advanced Life Support (ALS) assessment was performed by [text:Provider]."
      },
      {
        text: "Basic Life Support (BLS) assessments were conducted by [text:Provider]."
      }
    ]
  },
  {
    part: "R",
    includeTitle: true,
    sentences: [
      {
        text: "The patientâ€™s vital signs, along with any performed interventions, are detailed in the treatment section."
      },
      {
        text: "Additional interventions were necessary to manage the patientâ€™s condition due to [text:Additional Reason], and these included [text:Interventions]."
      },
      {
        text: "The patientâ€™s condition [customDropdown:Patient Condition] during transport.."
      }
    ]
  },
  {
    part: "T",
    includeTitle: true,
    sentences: [
      {
        text: "The patient was transferred to the stretcher via [customDropdown:Method] with assistance [customDropdown:Assist Count], secured with [customDropdown:Straps Count] straps, and loaded into [customDropdown:Unit #], without complications."
      },
      {
        text: "The patient was transported to [text:Receiving Facility]."
      },
      {
        text: "Upon arrival, the patientâ€™s condition was [text:Arrival Condition]."
      },
      {
        text: "The patient was transferred to [customDropdown:Transfer of Location] via [customDropdown:Method] with assistance [customDropdown:Assist Count], without complications."
      },
      {
        text: "A full report was provided to [text:Receiving Provider]."
      }
    ]
  },
  {
    part: "M",
    includeTitle: true,
    sentences: [
      {
        text: "The medical necessity for ambulance transport was justified because [customDropdown:Medical Necessity]."
      },
      {
        text: "The patient was taken to [text:Destination] due to the need for [customDropdown:Reason] that [customDropdown:Sending Facility] was unable to provide."
      }
    ]
  },
  {
    part: "Sign Off",
    includeTitle: false,
    sentences: [
      {
        text: "I, [text:Provider], hereby certify that the above findings are accurate and complete to the best of my knowledge."
      }
    ]
  }
];

/** 
 * Removes placeholders & returns something like "[IV Size]" for displaying suggestions.
 */
function shortPlaceholderString(sentence) {
  return sentence.replace(placeholderRegex, (match, type, label, opts) => {
    return `[${label}]`;
  });
}

/** 
 * Expands placeholders, e.g. "[customDropdown:IV Size:14G,16G]" => "[IV Size(14G,16G)]"
 * So searching "14G" or "IV Size" can match.
 */
function expandedPlaceholderString(sentence) {
  return sentence.replace(placeholderRegex, (match, theType, label, opts) => {
    if (!opts) {
      return `[${label}]`;
    }
    return `[${label}(${opts})]`;
  });
}

/**
 * Reassign fresh IDs (sentence-1, sentence-2, etc.) to each sentence 
 * so we keep them unique and in ascending order.
 */
function assignDynamicIDs() {
  let counter = 1;
  dchartSections.forEach(section => {
    section.sentences.forEach(sentenceObj => {
      sentenceObj.id = "sentence-" + counter++;
    });
  });
}

/**
 * Grab the current inline-field values from the DOM back into our data structure.
 * This ensures we don't lose typed data after re-build or drag reorder.
 */
function storeAllInlineValues() {
  dchartSections.forEach(section => {
    section.sentences.forEach(sentenceObj => {
      const li = document.querySelector(`li[data-id="${sentenceObj.id}"]`);
      if (!li) return;
      const fields = Array.from(li.querySelectorAll(".inline-field"));
      if (!sentenceObj.values) {
        sentenceObj.values = [];
      }
      fields.forEach((field, idx) => {
        sentenceObj.values[idx] = field.value;
      });
    });
  });
}

/**
 * Build the entire UI from dchartSections:
 *  - Each section with a "part" label
 *  - The sentence list
 *  - The "Add new sentence" form with suggestions
 */
function buildSections() {
  // Store typed fields first
  storeAllInlineValues();
  // Reassign sentence IDs
  assignDynamicIDs();

  const container = document.getElementById("sectionContainer");
  container.innerHTML = "";

  dchartSections.forEach((secObj) => {
    const sectionDiv = document.createElement("div");
    sectionDiv.classList.add("dchart-section");
    sectionDiv.dataset.part = secObj.part;

    // Section header
    const header = document.createElement("div");
    header.classList.add("section-header");
    const titleEl = document.createElement("h5");
    titleEl.classList.add("section-title");
    titleEl.innerText = secObj.part;
    header.appendChild(titleEl);
    sectionDiv.appendChild(header);

    // Sentence list
    const ul = document.createElement("ul");
    ul.classList.add("sentence-list");
    ul.dataset.part = secObj.part;

    // Add each sentence as <li>
    secObj.sentences.forEach((sentenceObj) => {
      const li = document.createElement("li");
      li.dataset.id = sentenceObj.id;

      // Drag handle
      const handle = document.createElement("span");
      handle.classList.add("drag-handle");
      handle.innerHTML = "&#9776;";
      li.appendChild(handle);

      // Insert placeholders / inline fields
      const contentWrapper = document.createElement("span");
      contentWrapper.innerHTML = buildInlineFields(sentenceObj);
      li.appendChild(contentWrapper);

      // Remove button
      const removeBtn = document.createElement("button");
      removeBtn.classList.add("remove-sentence-btn");
      removeBtn.type = "button";
      removeBtn.innerHTML = "&times;";
      removeBtn.title = "Remove this sentence";
      removeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        if (confirm("Remove this sentence?")) {
          removeSentence(secObj.part, sentenceObj.id);
          buildSections();
        }
      });
      li.appendChild(removeBtn);

      ul.appendChild(li);
    });

    sectionDiv.appendChild(ul);

    // "Add item" form with fuse suggestions
    const form = document.createElement("form");
    form.classList.add("add-item-form");
    form.dataset.part = secObj.part;

    const groupDiv = document.createElement("div");
    groupDiv.classList.add("add-item-group");

    const input = document.createElement("input");
    input.type = "text";
    input.classList.add("form-control", "form-control-sm");
    input.placeholder = "add a new sentence...";

    const addBtn = document.createElement("button");
    addBtn.type = "submit";
    addBtn.classList.add("btn", "btn-sm", "btn-secondary");
    addBtn.innerText = "Add";

    groupDiv.appendChild(input);
    groupDiv.appendChild(addBtn);

    // The suggestions container
    const suggestionsBox = document.createElement("div");
    suggestionsBox.classList.add("suggestions-box");
    suggestionsBox.innerHTML = `<ul></ul>`;

    form.appendChild(groupDiv);
    form.appendChild(suggestionsBox);

    // Handle "Add new sentence"
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const newText = input.value.trim();
      if (newText) {
        secObj.sentences.push({ text: newText });
        buildSections();
      }
    });

    // Fuse search on input
    input.addEventListener("input", () => {
      const query = input.value.trim();
      if (!query) {
        suggestionsBox.style.display = "none";
        return;
      }

      // Get matches from Fuse
      const fuseResults = fuse.search(query);
      if (fuseResults.length === 0) {
        suggestionsBox.style.display = "none";
        return;
      }

      // Build suggestions list (no highlighting, just plain text)
      const ulEl = suggestionsBox.querySelector("ul");
      ulEl.innerHTML = "";
      fuseResults.forEach(res => {
        // res.item => { original, display, searchable }
        const li = document.createElement("li");
        // Just show the display text (no bold or highlight)
        li.textContent = res.item.display;

        li.addEventListener("mousedown", () => {
          // Add the original text into this section
          secObj.sentences.push({ text: res.item.original });
          input.value = "";
          suggestionsBox.style.display = "none";
          buildSections();
        });
        ulEl.appendChild(li);
      });

      suggestionsBox.style.display = "block";
    });

    // Hide suggestions on blur
    input.addEventListener("blur", () => {
      setTimeout(() => {
        suggestionsBox.style.display = "none";
      }, 150);
    });

    sectionDiv.appendChild(form);
    container.appendChild(sectionDiv);
  });

  // Make sentences draggable
  makeSentencesDraggable();
  attachDropdownLogic();
}

/** Remove a sentence from a given part by ID. */
function removeSentence(partLabel, sentenceId) {
  const section = dchartSections.find(s => s.part === partLabel);
  if (!section) {
    console.error(`Section "${partLabel}" not found.`);
    return;
  }
  const idx = section.sentences.findIndex(s => s.id === sentenceId);
  if (idx === -1) {
    console.error(`Sentence ID "${sentenceId}" not found in "${partLabel}".`);
    return;
  }
  section.sentences.splice(idx, 1);
}

/**
 * Insert placeholders as inline <input> fields for easy editing.
 */
function buildInlineFields(sentenceObj) {
  let placeholderIndex = 0;
  // remove any <br> from original text
  const noBr = sentenceObj.text.replace(/<br\s*\/?>/gi, "");

  return noBr.replace(placeholderRegex, (match, type, label, options) => {
    const val = (sentenceObj.values && sentenceObj.values[placeholderIndex]) || "";
    placeholderIndex++;

    // If we have inline placeholder options, use them. Else check global.
    let optsArray = [];
    if (options) {
      optsArray = options.split(",").map(x => x.trim());
    } else if (globalDropdownOptions[label]) {
      optsArray = globalDropdownOptions[label];
    }

    // Build a custom dropdown if type===customDropdown, etc.
    if (type === "customDropdown") {
      const listItems = optsArray
        .map(opt => `<li class="list-group-item">${opt}</li>`)
        .join("");
      return `
        <div class="custom-dropdown">
          <input
            type="text"
            autocapitalize="none"
            class="inline-field custom-dropdown-input"
            data-type="customDropdown"
            data-label="${label}"
            placeholder="${label}"
            value="${val}"
          />
          <ul class="suggestions">${listItems}</ul>
        </div>
      `;
    }
    else if (type === "dropdown") {
      const dlId = "dl-" + Math.random().toString(36).substring(2);
      let dataListHTML = `<datalist id="${dlId}">`;
      optsArray.forEach(opt => {
        dataListHTML += `<option value="${opt}"></option>`;
      });
      dataListHTML += `</datalist>`;
      return `
        <span style="white-space:nowrap;">
          <input
            type="text"
            autocapitalize="none"
            list="${dlId}"
            class="inline-field"
            data-type="dropdown"
            data-label="${label}"
            placeholder="${label}"
            value="${val}"
          />
          ${dataListHTML}
        </span>
      `;
    }
    else if (type === "text") {
      return `
        <input
          type="text"
          autocapitalize="none"
          class="inline-field"
          data-type="text"
          data-label="${label}"
          placeholder="${label}"
          value="${val}"
        />
      `;
    }
    else if (type === "number") {
      return `
        <input
          type="number"
          autocapitalize="none"
          class="inline-field"
          data-type="number"
          data-label="${label}"
          placeholder="${label}"
          value="${val}"
        />
      `;
    }
    // If unknown type, just return match
    return match; 
  });
}

/**
 * Make sentences reorderable between sections with SortableJS.
 */
function makeSentencesDraggable() {
  const lists = document.querySelectorAll(".sentence-list");
  lists.forEach(ul => {
    new Sortable(ul, {
      animation: 150,
      group: { name: "dchartGroup", pull: true, put: true },
      handle: ".drag-handle",
      onEnd: () => {
        // Store typed fields before reading DOM
        storeAllInlineValues();

        // Build a dictionary by ID
        const sentenceMap = {};
        dchartSections.forEach(sec => {
          sec.sentences.forEach(sent => {
            sentenceMap[sent.id] = sent;
          });
        });

        // Clear old data
        dchartSections.forEach(sec => {
          sec.sentences = [];
        });

        // Re-read DOM in new order
        const container = document.getElementById("sectionContainer");
        const partDivs = Array.from(container.querySelectorAll(".dchart-section"));
        partDivs.forEach(div => {
          const partLabel = div.dataset.part;
          const section = dchartSections.find(s => s.part === partLabel);
          if (!section) return;

          const ulEl = div.querySelector(".sentence-list");
          const liArray = Array.from(ulEl.children).filter(child => child.matches("li[data-id]"));
          liArray.forEach(li => {
            const id = li.dataset.id;
            if (sentenceMap[id]) {
              section.sentences.push(sentenceMap[id]);
            } else {
              console.warn(`ID "${id}" not found in dictionary. Possibly new?`);
              section.sentences.push({ id, text: li.innerText });
            }
          });
        });

        // Rebuild
        buildSections();
      }
    });
  });
  attachDropdownLogic();
}

/** 
 * Attach dropdown logic for placeholders (like [customDropdown:IV Size]), 
 * so that focusing shows a suggestion list, arrow keys, etc.
 */
function attachDropdownLogic() {
  document.querySelectorAll(".custom-dropdown").forEach((dropdown) => {
    const input = dropdown.querySelector(".custom-dropdown-input");
    const suggestionBox = dropdown.querySelector(".suggestions");
    if (!input || !suggestionBox) return;

    let focusedIndex = -1;
    const items = Array.from(suggestionBox.querySelectorAll("li"));

    input.addEventListener("focus", () => {
      suggestionBox.style.display = "block";
    });
    input.addEventListener("blur", () => {
      setTimeout(() => {
        suggestionBox.style.display = "none";
        clearHighlight();
      }, 150);
    });
    items.forEach((li, idx) => {
      li.addEventListener("mousedown", () => {
        input.value = li.textContent.trim();
      });
    });
    input.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 38: // up
          e.preventDefault();
          if (focusedIndex > 0) focusedIndex--;
          else focusedIndex = items.length - 1;
          highlight(focusedIndex);
          break;
        case 40: // down
          e.preventDefault();
          if (focusedIndex < items.length - 1) focusedIndex++;
          else focusedIndex = 0;
          highlight(focusedIndex);
          break;
        case 13: // enter
          e.preventDefault();
          if (focusedIndex >= 0 && focusedIndex < items.length) {
            input.value = items[focusedIndex].textContent.trim();
          }
          suggestionBox.style.display = "none";
          input.blur();
          break;
        case 27: // esc
          e.preventDefault();
          suggestionBox.style.display = "none";
          clearHighlight();
          break;
      }
    });

    function highlight(index) {
      items.forEach(item => item.classList.remove("highlight"));
      if (index >= 0 && index < items.length) {
        items[index].classList.add("highlight");
      }
    }
    function clearHighlight() {
      focusedIndex = -1;
      items.forEach(item => item.classList.remove("highlight"));
    }
  });
}

/** 
 * Generate final text by reading each section & sentence from the DOM order 
 * and substituting placeholders with user-typed values. 
 */
document.getElementById("generateBtn").addEventListener("click", () => {
  const finalText = generateFinalText();
  const finalTextArea = document.getElementById("finalText");
  if (finalTextArea.value.trim()) {
    if (!confirm("This will override the current final narrative. Continue?")) {
      return;
    }
  }
  finalTextArea.value = finalText;
});

function generateFinalText() {
  storeAllInlineValues(); // ensure placeholders are up to date

  const includeSectionTitles = document.getElementById("toggleSectionTitles").checked;
  let output = "";
  const container = document.getElementById("sectionContainer");
  const partDivs = Array.from(container.querySelectorAll(".dchart-section"));

  partDivs.forEach(div => {
    const partLabel = div.dataset.part;
    const sectionConfig = dchartSections.find(s => s.part === partLabel);

    // Optionally add section title
    if (sectionConfig && sectionConfig.includeTitle && includeSectionTitles) {
      output += partLabel + ":\n";
    }

    // Grab each sentence <li>, find its data object, and fill placeholders
    const ul = div.querySelector(".sentence-list");
    const liArray = Array.from(ul.children).filter(child => child.matches("li[data-id]"));
    liArray.forEach(li => {
      const sentenceId = li.dataset.id;
      const sentenceObj = findSentenceById(sentenceId);
      if (!sentenceObj) {
        console.warn(`Sentence with ID "${sentenceId}" not found.`);
        return;
      }

      let placeholderIndex = 0;
      let replaced = sentenceObj.text.replace(placeholderRegex, () => {
        const val = sentenceObj.values && sentenceObj.values[placeholderIndex]
          ? sentenceObj.values[placeholderIndex].trim()
          : "_";
        placeholderIndex++;
        return val;
      });

      // Remove any <br> from the final text
      replaced = replaced.replace(/<br\s*\/?>/gi, "");

      if (replaced) {
        output += replaced + " ";
      }
    });

    output += "\n\n"; // blank line between sections
  });

  return output.trim();
}

/** 
 * Copy final text to clipboard 
 */
document.getElementById("copyBtn").addEventListener("click", () => {
  const finalTextArea = document.getElementById("finalText");
  if (!finalTextArea.value.trim()) {
    alert("Nothing to copy! Generate the text first.");
    return;
  }
  navigator.clipboard.writeText(finalTextArea.value)
    .then(() => {
      alert("Copied to clipboard!");
    })
    .catch((err) => {
      console.error("Could not copy text: ", err);
      alert("Failed to copy text.");
    });
});

/** 
 * Once DOM is ready, build initial interface 
 */
document.addEventListener("DOMContentLoaded", () => {
  buildSections();
});

/** 
 * Finds a sentence object by ID in all sections.
 */
function findSentenceById(id) {
  for (const sec of dchartSections) {
    const s = sec.sentences.find(x => x.id === id);
    if (s) return s;
  }
  return null;
}
</script>
</body>
</html>
